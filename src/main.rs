#[macro_use]
extern crate rocket;
extern crate base64;
use rocket::form::Form;
use rocket::http::Status;
use rocket::request::{FromRequest, Outcome, Request};
use sha2::{Digest, Sha256};
use std::collections::HashMap;

static SUCCESS_MESSAGE: &str = "Hello, admin!";
static FAIL_MESSAGE: &str = "Who are you? I didn't call you!";

#[derive(Debug)]
enum ApiTokenError {
    Missing,
    Invalid,
}

#[derive(FromForm)]
struct Credentials<'r> {
    username: &'r str,
    password: &'r str,
}

#[derive(Debug)]
struct Token(String);

#[rocket::async_trait]
impl<'r> FromRequest<'r> for Token {
    type Error = ApiTokenError;

    async fn from_request(request: &'r Request<'_>) -> Outcome<Self, Self::Error> {
        let token = request.headers().get_one("Authorization");

        fn is_valid(token: &str) -> bool {
            token.starts_with("Bearer ")
        }

        match token {
            // token does not exist
            None => Outcome::Failure((Status::Unauthorized, ApiTokenError::Missing)),
            // token is valid
            Some(token) if is_valid(token) => Outcome::Success(Token(token.to_string())),
            // token is invalid
            Some(_) => Outcome::Failure((Status::Unauthorized, ApiTokenError::Invalid)),
        }
    }
}

// Who will guess that username is 'username' and password is 'password'?
#[post("/auth1", data = "<creds>")]
fn auth1(creds: Form<Credentials<'_>>) -> String {
    let mut credentials = HashMap::new();
    credentials.insert(
        "username".to_string(),
        "5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8".to_string(),
    );

    fn hash_password(password: &str) -> String {
        let mut sha256 = Sha256::new();
        sha256.update(password);
        return format!("{:X}", sha256.finalize()).to_lowercase();
    }

    match credentials.get(creds.username) {
        None => FAIL_MESSAGE.to_string(),
        Some(password) if password.to_string() == hash_password(creds.password) => {
            SUCCESS_MESSAGE.to_string()
        }
        Some(_) => FAIL_MESSAGE.to_string(),
    }
}

// Uning a token is always a good idea! Who knows what's inside of it?)
#[post("/auth2")]
fn auth2(token: Token) -> String {
    let token_parts: Vec<&str> = token.0.split(" ").collect();
    let raw_token = token_parts[1];

    let raw_token_data = base64::decode(raw_token);

    match raw_token_data {
        Ok(_) => (),
        Err(_) => return FAIL_MESSAGE.to_string(),
    };

    let token_data: String = String::from_utf8(raw_token_data.unwrap()).unwrap();

    return match token_data.as_str() {
        "admin" => SUCCESS_MESSAGE.to_string(),
        _ => FAIL_MESSAGE.to_string(),
    };
}

// We will store hashes in order to protect our user's data, and those hashes will be generated by the front-end, so we will increase our backend performance! What could go wrong?
#[post("/auth3", data = "<creds>")]
fn auth3(creds: Form<Credentials<'_>>) -> String {
    let mut credentials = HashMap::new();
    credentials.insert(
        "admin".to_string(),
        "24a7bf80a38629a65f3b52b335b02cef0b3e483ee287bab69fefd7ac707f3dd1".to_string(),
    );

    match credentials.get(creds.username) {
        None => FAIL_MESSAGE.to_string(),
        Some(password) if password.to_string() == creds.password => SUCCESS_MESSAGE.to_string(),
        Some(_) => FAIL_MESSAGE.to_string(),
    }
}

#[launch]
fn rocket() -> _ {
    rocket::build().mount("/", routes![auth1, auth2, auth3])
}
